<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>TextChangeLog</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 1000px; margin: auto; }
    textarea, pre { width: 100%; height: 200px; font-family: monospace; }
    button { margin: 10px 5px 10px 0; }
    #reconstructed { white-space: pre-wrap; border: 1px solid #ccc; padding: 10px; background: #f9f9f9; }
    summary { cursor: pointer; font-weight: bold; margin-top: 1em; }
    .section { margin-top: 30px; }
  </style>
</head>
<body>

  <h2>üìù TextChangeLog (mit JWS-Signatur, Import/Export, Erkl√§rung)</h2>

  <div>
    <label><strong>Editor:</strong></label><br>
    <textarea id="editor" placeholder="Hier schreiben..."></textarea>
    <button onclick="resetEditor()">Reset</button>
    <button onclick="signText()">üñã Signieren</button>
  </div>

  <details open>
    <summary>‚úèÔ∏è Delta-Log (editierbar)</summary>
    <textarea id="deltaLog" placeholder="Delta-Befehle hier..."></textarea>
    <button onclick="downloadLog()">‚¨áÔ∏è Download Log (.txt)</button>
    <input type="file" id="upload" accept=".txt" onchange="loadLogFromFile(event)">
  </details>

  <div class="section">
    <button onclick="stepReplay()">‚ûï N√§chster Schritt</button>
    <button onclick="replayAll()">‚ñ∂Ô∏è Alles wiederherstellen</button>
    <span id="currentLineInfo"></span>
  </div>

  <div>
    <h3>üìÑ Wiederhergestellter Text</h3>
    <pre id="reconstructed"></pre>
  </div>

<script>
  const editor = document.getElementById("editor");
  const deltaLogField = document.getElementById("deltaLog");
  const reconstructed = document.getElementById("reconstructed");
  const currentLineInfo = document.getElementById("currentLineInfo");

  let lastValue = "";
  let stepIndex = 0;
  let privateKey;

  // ==== TEXT √ÑNDERUNG TRACEN ====
  editor.addEventListener("input", () => {
    const newValue = editor.value;
    const selectionStart = editor.selectionStart;
    const deltaLines = computeDeltas(lastValue, newValue, selectionStart);
    if (deltaLines.length > 0) {
      deltaLogField.value += deltaLines.join("\n") + "\n";
      lastValue = newValue;
    }
  });

  function computeDeltas(oldText, newText, cursorPos) {
    let deltas = [];

    if (oldText === newText) return [];

    let prefixLength = 0;
    while (
      prefixLength < oldText.length &&
      prefixLength < newText.length &&
      oldText[prefixLength] === newText[prefixLength]
    ) {
      prefixLength++;
    }

    let suffixLength = 0;
    while (
      suffixLength + prefixLength < oldText.length &&
      suffixLength + prefixLength < newText.length &&
      oldText[oldText.length - 1 - suffixLength] === newText[newText.length - 1 - suffixLength]
    ) {
      suffixLength++;
    }

    const removed = oldText.slice(prefixLength, oldText.length - suffixLength);
    const inserted = newText.slice(prefixLength, newText.length - suffixLength);

    if (removed.length > 0) {
      deltas.push(`<${prefixLength}:<${removed.length}`);
    }
    if (inserted.length > 0) {
      const safeInsert = inserted.replace(/\n/g, "\\n");
      deltas.push(`>${prefixLength}:${safeInsert}`);
    }

    return deltas;
  }

  function resetEditor() {
    editor.value = "";
    deltaLogField.value = "";
    reconstructed.textContent = "";
    currentLineInfo.textContent = "";
    lastValue = "";
    stepIndex = 0;
  }

  function stepReplay() {
    const lines = deltaLogField.value.split("\n");
    if (stepIndex >= lines.length) return;

    let output = reconstructed.textContent.replace(/^\/\/.*\n/, "");
    const line = lines[stepIndex];
    
    //validate signature
    if (line.startsWith("# JWS:")) {
      await verifyJWSLine(text, line);
    }

    output = applyDelta(output, line);
    reconstructed.textContent = `// Zeile ${stepIndex + 1}: ${line}\n` + output;
    currentLineInfo.textContent = `Delta ${stepIndex + 1}/${lines.length}`;
    stepIndex++;
  }

  function replayAll() {
    stepIndex = 0;
    reconstructed.textContent = "";
    const lines = deltaLogField.value.split("\n");
    let output = "";

    for (let i = 0; i < lines.length; i++) {
      //validate signature
      if (line.startsWith("# JWS:")) {
        await verifyJWSLine(text, line);
      }
      output = applyDelta(output, lines[i]);
    }

    reconstructed.textContent = output;
    currentLineInfo.textContent = `Alle ${lines.length} Zeilen verarbeitet.`;
  }

  function applyDelta(text, line) {
    const insert = line.match(/^>(\d+):([\s\S]*)$/);
    const remove = line.match(/^<(\d+):<(\d+)$/);

    if (insert) {
      const pos = parseInt(insert[1]);
      const str = insert[2].replace(/\\n/g, "\n");
      return text.slice(0, pos) + str + text.slice(pos);
    }

    if (remove) {
      const pos = parseInt(remove[1]);
      const len = parseInt(remove[2]);
      return text.slice(0, pos) + text.slice(pos + len);
    }

    return text;
  }

  // === SIGNATUR ===

  async function alt_signText() {
    const fullText = reconstructed.textContent;
    const textWithoutJWS = fullText.replace(/^# JWS:.*$/gm, "").trim();
    const enc = new TextEncoder();
    const data = enc.encode(textWithoutJWS);

    if (!privateKey) {
      privateKey = await window.crypto.subtle.generateKey(
        { name: "ECDSA", namedCurve: "P-256" },
        true,
        ["sign", "verify"]
      );
    }

    const signature = await crypto.subtle.sign(
      { name: "ECDSA", hash: "SHA-256" },
      privateKey,
      data
    );

    const sigB64 = base64url(signature);

    const sigLine = `# JWS: ${sigB64}`;
    const deltaLine = `>${textWithoutJWS.length}:# JWS: ${sigB64}\\n`;



    deltaLogField.value += deltaLine + "\n";
    editor.value += `\n# JWS: ${sigB64}`;
    lastValue = editor.value;
  }

  function alt_base64url(buffer) {
    return btoa(String.fromCharCode(...new Uint8Array(buffer)))
      .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }

<!--scriptteil 2-->
  // === Download Delta-Log als Base64url-codierte Textdatei ===
  function downloadLog() {
    let filename = prompt("Dateiname f√ºr Delta-Log (ohne Endung):", `delta-log-${new Date().toISOString().slice(0,10)}`);
    if (!filename) return;
    let logText = deltaLogField.value.trim();

    // Base64url kodieren
    const utf8encoder = new TextEncoder();
    const bytes = utf8encoder.encode(logText);
    let b64 = btoa(String.fromCharCode(...bytes))
      .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");

    const blob = new Blob([b64], {type: "text/plain"});
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = filename + ".txt";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // === Datei-Upload und Log laden ===
  function loadLogFromFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = e => {
      let b64 = e.target.result.trim();
      try {
        // Base64url -> Uint8Array -> Text
        b64 = b64.replace(/-/g, "+").replace(/_/g, "/");
        while (b64.length % 4) b64 += "=";
        const str = atob(b64);
        const bytes = new Uint8Array(str.length);
        for(let i=0; i<str.length; i++) bytes[i] = str.charCodeAt(i);

        const utf8decoder = new TextDecoder();
        const text = utf8decoder.decode(bytes);

        deltaLogField.value = text;
        lastValue = "";
        replayAll();
      } catch {
        alert("Fehler beim Decodieren der Datei");
      }
    };
    reader.readAsText(file);
  }

  // === Querystring auslesen ===
  function loadLogFromQuery() {
    const params = new URLSearchParams(window.location.search);
    const logB64 = params.get("log");
    if (!logB64) return;

    try {
      let b64 = logB64.replace(/-/g, "+").replace(/_/g, "/");
      while (b64.length % 4) b64 += "=";
      const str = atob(b64);
      const bytes = new Uint8Array(str.length);
      for(let i=0; i<str.length; i++) bytes[i] = str.charCodeAt(i);

      const utf8decoder = new TextDecoder();
      const text = utf8decoder.decode(bytes);

      deltaLogField.value = text;
      lastValue = "";
      replayAll();
    } catch {
      console.warn("Kein g√ºltiger Log im Querystring");
    }
  }

  // === Erkl√§rung Sektion anh√§ngen ===
  function appendProtocolExplanation() {
    const explanation = document.createElement("details");
    explanation.innerHTML = `
      <summary>‚ÑπÔ∏è Delta-Protokoll Erkl√§rung</summary>
      <pre style="white-space: pre-wrap; background:#f0f0f0; padding: 10px; border: 1px solid #ccc; margin-top: 10px;">
Die Deltas bestehen aus 2 Befehlsarten:

  >POS:TEXT
    F√ºgt ab Position POS den Text TEXT ein.
    Beispiel: &gt;3:abc  ersetzt ab Position 3 mit "abc".
    '\n' im Text wird als "\\n" gespeichert.

  &lt;POS:&lt;L√ÑNGE
    L√∂scht ab Position POS die Anzahl L√ÑNGE von Zeichen.
    Beispiel: &lt;4:&lt;2 l√∂scht 2 Zeichen ab Position 4.

Alle Zeilen, die nicht mit &gt; oder &lt; beginnen, werden als Klartext (Kommentare) an das Dokument angeh√§ngt.

Signaturen (JWS) werden als Kommentarzeile angeh√§ngt, z.B.:
  # JWS: eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9...

Der Log kann genutzt werden, um Schritt f√ºr Schritt oder vollst√§ndig den Text wiederherzustellen.

    </pre>
    `;
    document.body.appendChild(explanation);
  }

  // === Init ===
  window.onload = () => {
    loadLogFromQuery();
    appendProtocolExplanation();
  };
</script>

<script>// Signature

let keyPair = null;

// Signatur ausf√ºhren und ins Dokument einf√ºgen
async function signText() {
  const rawText = reconstructed.textContent;
  const textWithoutJWS = rawText.replace(/^# JWS:.*$/gm, "").trim();

  // Erzeuge Keypaar (einmalig ‚Äì Demo!)
  if (!keyPair) {
    keyPair = await crypto.subtle.generateKey(
      { name: "ECDSA", namedCurve: "P-256" },
      true,
      ["sign", "verify"]
    );
  }

  const encoder = new TextEncoder();
  const data = encoder.encode(textWithoutJWS);

  // Signiere die Daten
  const signature = await crypto.subtle.sign(
    { name: "ECDSA", hash: { name: "SHA-256" } },
    keyPair.privateKey,
    data
  );

  const sigBase64url = base64url(signature);
  const jwsLine = `# JWS: ${sigBase64url}`;
  const jwsDelta = `>\\n${textWithoutJWS.length}:# JWS: ${sigBase64url}\\n`;
  //const deltaLine = `>\\n${textWithoutJWS.length}:# JWS: ${sigBase64url}\\n`;

  // In Text und Log einf√ºgen
  editor.value += `\n${jwsLine}\n`;
  deltaLogField.value += jwsDelta + "\n";
  lastValue = editor.value;

  // Optional: Wiederhergestellten Text aktualisieren
  replayAll();
}

// Hilfsfunktion: ArrayBuffer ‚Üí base64url
function base64url(buffer) {
  return btoa(String.fromCharCode(...new Uint8Array(buffer)))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/, "");
}

async function importPrivateKey(jwk) {
  return await crypto.subtle.importKey(
    "jwk",
    jwk,
    { name: "ECDSA", namedCurve: "P-256" },
    true,
    ["sign"]
  );
}

async function importPublicKey(jwk) {
  return await crypto.subtle.importKey(
    "jwk",
    jwk,
    { name: "ECDSA", namedCurve: "P-256" },
    true,
    ["verify"]
  );
}

async function exportKeyPair() {
  if (!keyPair) return;

  const jwkPrivate = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
  const jwkPublic = await crypto.subtle.exportKey("jwk", keyPair.publicKey);

  console.log("üîê Private JWK:", jwkPrivate);
  console.log("üîì Public JWK:", jwkPublic);
}

async function verifyJWSLine(textSoFar, jwsLine) {
  if (!keyPair || !keyPair.publicKey) {
    alert("‚ö†Ô∏è Kein Public Key vorhanden f√ºr Verifikation.");
    return false;
  }

  const match = jwsLine.match(/^# JWS:\s*(.+)$/);
  if (!match) return false;

  const sig = base64urlToBytes(match[1]);
  const data = new TextEncoder().encode(textSoFar.trim());

  const isValid = await crypto.subtle.verify(
    { name: "ECDSA", hash: "SHA-256" },
    keyPair.publicKey,
    sig,
    data
  );

  if (!isValid) {
    alert("‚ùå Signaturpr√ºfung fehlgeschlagen!");
  } else {
    console.log("‚úÖ Signatur g√ºltig.");
  }

  return isValid;
}

// Hilfsfunktion: base64url ‚Üí Uint8Array
function base64urlToBytes(b64url) {
  const b64 = b64url.replace(/-/g, "+").replace(/_/g, "/") + "==".slice(0, (4 - b64url.length % 4) % 4);
  const binary = atob(b64);
  return new Uint8Array([...binary].map(c => c.charCodeAt(0)));
}


const jwk = {
  kty: "EC",
  crv: "P-256",
  x: "....",
  y: "....",
  d: "...."  // nur f√ºr private key
};

keyPair = {
  privateKey: await importPrivateKey(jwk),
  publicKey: await importPublicKey(jwk)
};


</script>
</body>
</html>

