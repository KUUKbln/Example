<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üé¨ Cutlist</title>
  <link href="libs/video-js.min.css" rel="stylesheet" />
  <style>
   body {
  font-family: sans-serif;
  background-color: #111;
  color: #eee;
  margin: 0;
  padding: 1em;
}

h1, h2 {
  text-align: center;
}

iframe {
  width: 100%;
  max-width: 800px;
  height: 450px;
  display: block;
  margin: 1em auto;
  border: none;
}

#ytplayer {
  width: 100%;
  max-width: 800px;
  height: 450px;
  margin: 1em auto;
}

.scene-buttons {
  margin-bottom: 2em;
  max-width: 800px;
  margin-left: auto;
  margin-right: auto;
}

.scene-button {
  font-family: Courier, monospace;
  background-color: white;
  color: black;
  border: none;
  padding: 10px;
  margin: 5px 0;
  width: calc(100% - 30px);
  text-align: left;
  display: inline-block;
  border-radius: 4px;
  cursor: pointer;
  white-space: pre-line;
}

.scene-button:hover {
  background-color: #f0f0f0;
}

.scene-link {
  margin-left: 10px;
  text-decoration: none;
  color: #ccc;
  font-size: 1.2em;
  vertical-align: middle;
}

.scene-link:hover {
  color: white;
}

.quote {
  text-align: center;
  font-style: italic;
  margin: 1em 0;
  white-space: pre-line;
}

details {
  background: #222;
  padding: 1em;
  margin: 1em auto;
  border-radius: 5px;
  max-width: 800px;
}

textarea {
  width: 100%;
  min-height: 200px;
  background: #111;
  color: #eee;
  border: 1px solid #444;
  padding: 1em;
  font-family: monospace;
  resize: vertical;
}

.controls {
  text-align: center;
  margin: 1em 0;
}

.controls button {
  margin: 0.5em;
  padding: 0.5em 1em;
  background: #333;
  border: none;
  color: white;
  border-radius: 4px;
  cursor: pointer;
}

.controls button:hover {
  background-color: #555;
}

.progress-overlay {
  text-align: center;
  font-size: 1em;
  color: #aaa;
  margin-top: 1em;
}

@media (max-width: 600px) {
  iframe, #ytplayer {
    height: 200px;
  }

  .scene-button {
    font-size: 0.9em;
  }
}

  </style>
</head>
<body>
  <h1>üé¨ Cutlist Video Player</h1>

  <!-- Video.js Player -->
  <video
    id="ytplayer"
    class="video-js vjs-default-skin"
    controls
    preload="auto"
    width="800"
    height="450"
    data-setup='{}'
  ></video>

  <div class="controls">
    <button onclick="toggleAutoPlay()">üîÅ Auto: <span id="autoPlayStatus">AN</span></button>
  </div>

  <div class="scene-buttons" id="sceneButtons"></div>
  <div class="quote" id="sceneQuote">Szene nicht gestartet</div>
  <div class="progress-overlay" id="progressDisplay">üé¨ Szene 0 / 0</div>

  <details open>
    <summary>üìÅ Geladene JSON bearbeiten</summary>
    <textarea id="cutlistEditor" spellcheck="false"></textarea>
    <div class="controls">
      <button onclick="applyCutlistFromEditor()">‚úÖ √úbernehmen</button>
      <button onclick="downloadCutlist()">‚¨áÔ∏è Download</button>
    </div>
  </details>

  <details>
    <summary>üìå Anleitung: Transkript per Bookmarklet laden</summary>
    <p>Benutze das Bookmarklet im YouTube-Transkript, um es zu kopieren und als Datei zu speichern. Lade diese Datei sp√§ter in deinen Editor und verarbeite sie mit ChatGPT oder manuell.</p>
  </details>

  <details>
    <summary>ü§ñ Anleitung: Cutlist von ChatGPT erstellen lassen</summary>
    <p>Gib ChatGPT folgende Anleitung:</p>
    <pre><code>
Du erstellst eine Zusammenfassung f√ºr mehrere Youtube-Videos.
Bitte frage mich nach dem Thema und dann nach allen ben√∂tigten Transkript-Texten der Youtube-Videos.
Bitte erstelle daraus eine Cutlist mit Zitaten und Zeitangaben im folgenden JSON-Format:

{
  "videos": [...],
  "scenes": [...],
  "output": {
    "title": "...",
    "description": "...",
    "tags": [...],
    "notes": "..."
  }
}
    </code></pre>
  </details>

  <details>
    <summary>üìê Formatbeispiel f√ºr JSON-Cutlist</summary>
    <pre><code>{
  "videos": [
    {
      "title": "Titel",
      "youtubeID": "abc123",
      "youtubeURL": "https://youtube.com/watch?v=abc123",
      "summaryInstruction": "Zusammenfassung...",
      "transcriptPath": "transcripts/datei.txt",
      "localVideoPath": null
    }
  ],
  "scenes": [
    {
      "start": 10,
      "end": 20,
      "quote": "Zitat",
      "note": "Hinweis",
      "tags": ["Tag1"],
      "sourceVideoID": "abc123"
    }
  ],
  "output": {
    "title": "Projekt",
    "description": "Beschreibung",
    "tags": ["Tag1", "Tag2"],
    "notes": "Sonstige Hinweise"
  }
}</code></pre>
  </details>

<script src="libs/video.min.js"></script>
<script src="libs/Youtube.min.js"></script>

<script>
  let cutlistData = null;
  let autoPlay = true;
  let currentSceneIndex = 0;
  let player = null;
  let sceneMonitor = null;
  let isSceneChanging = false; // global definieren
    
  function getCutlistFromQuery() {
    const params = new URLSearchParams(location.search);
    return params.get("cutlist");
  }

  async function loadCutlist(path) {
    try {
      const res = await fetch(path);
      if (!res.ok) throw new Error("Cutlist konnte nicht geladen werden.");
      return await res.json();
    } catch (e) {
      alert("‚ùå Fehler beim Laden der Cutlist: " + e.message);
      return null;
    }
  }

  async function init() {
    const cutlistFile = getCutlistFromQuery();
    /*"y8HoSXAR_LY",*/
    if (!cutlistFile) {
      const example = {
        "videos": [
          {
            "title": "Fler zu Shahak Shapira, Rezo und #unhatewomen",
            "youtubeID": "u7nz7leBEEg",
            "youtubeURL": "https://www.youtube.com/watch?v=y8HoSXAR_LY",
            "summaryInstruction": "Ausschnitte von Fler zu seinem Konflikt mit Shahak Shapira, Reaktionen auf #unhatewomen und Social Media Kritik",
            "transcriptPath": "transcripts/fler_shapira.txt",
            "localVideoPath": null
          },
          {
            "title": "Beef mit Fler | Shapira Shapira",
            "youtubeID": "brtBqtKh-3M",
            "youtubeURL": "https://www.youtube.com/watch?v=brtBqtKh-3M",
            "summaryInstruction": "Shapira erz√§hlt humorvoll und sarkastisch von seinem Beef mit Fler und den Reaktionen im Netz",
            "transcriptPath": "transcripts/shapira_fler.txt",
            "localVideoPath": null
          }
        ],
        "scenes": [
          {
            "start": 9,
            "end": 15,
            "quote": "gab es gestern auf twitter und auf instagram so ein riesen hin und her mit diesem m√∂chtegern comedian...",
            "note": "Fler √ºber den Ausl√∂ser des Streits mit Shapira",
            "tags": ["Fler", "Shapira", "Twitter", "Konflikt"],
            "sourceVideoID": "u7nz7leBEEg"
          },
          {
            "start": 7,
            "end": 12,
            "quote": "ich hatte mal beef mit flair... es war komplett meine schuld",
            "note": "Shapira beginnt selbstironisch mit dem Konflikt",
            "tags": ["Beef", "Shapira", "Ironie"],
            "sourceVideoID": "brtBqtKh-3M"
          },
          {
            "start": 27,
            "end": 32,
            "quote": "ich wollte flair keinesfalls ideologisch mit bernd r√∂cker vergleichen...",
            "note": "Shapira relativiert seinen kontroversen Vergleich",
            "tags": ["Vergleich", "Provokation", "Shapira"],
            "sourceVideoID": "brtBqtKh-3M"
          },
          {
            "start": 41,
            "end": 44,
            "quote": "einige stunden sp√§ter bin ich wieder auf facebook... flair hat kommentiert: 'sehen uns :)'",
            "note": "Fler reagiert ‚Äì erste Eskalationsstufe",
            "tags": ["Facebook", "Fler", "Shapira"],
            "sourceVideoID": "brtBqtKh-3M"
          }
        ],
        "output": {
          "title": "Fler vs. Shapira ‚Äì Social Media Beef & Eskalation",
          "description": "Schnittplan f√ºr ein satirisch-dokumentarisches Video √ºber den Streit zwischen Rapper Fler und Comedian Shahak Shapira. Enth√§lt Originalzitate beider Seiten, mediale Reaktionen, Fan-Kommentare sowie kritische Reflexion.",
          "tags": ["Fler", "Shapira", "Beef", "Satire", "Social Media", "Rap", "Kritik", "Medien", "#unhatewomen"],
          "notes": "Szenen stammen aus zwei YouTube-Videos; teilweise humorvoll, teilweise ernst. Ziel: ausgewogene Darstellung des Konflikts mit dramaturgischem Aufbau."
        }
      };
      cutlistData = example;
      document.getElementById("cutlistEditor").value = JSON.stringify(example, null, 2);
      initPlayer();
      return;
    }

    const data = await loadCutlist(cutlistFile);
    if (!data) return;

    cutlistData = data;
    document.getElementById("cutlistEditor").value = JSON.stringify(data, null, 2);
    initPlayer();
  }

  function toggleAutoPlay() {
    autoPlay = !autoPlay;
    document.getElementById("autoPlayStatus").innerText = autoPlay ? "AN" : "AUS";
  }

  function initPlayer() {
if (player) return;
    if (player) {
      console.log("dispose player");
      player.dispose();
     
      // Optional: DOM leeren, um sicherzugehen
      const container = document.getElementById("ytplayer");
      if (container) container.innerHTML = "";



      player = null;
    }

    if (!cutlistData || !cutlistData.scenes || cutlistData.scenes.length === 0) return;

    const firstScene = cutlistData.scenes[0];
    const video = cutlistData.videos.find(v => v.youtubeID === firstScene.sourceVideoID);
    console.log("init player for "+video.youtubeID+"  "+`https://www.youtube.com/watch?v=${video.youtubeID}`);
    
    
    player = videojs("ytplayer", {
      controls: true,
      autoplay: true,
      preload: "auto",
      techOrder: ["youtube"],
      sources: [
        {
          type: "video/youtube",
          src: `https://www.youtube.com/watch?v=${video.youtubeID}`
        }
      ],
      youtube: {
        modestbranding: 1,
        rel: 0,
        iv_load_policy: 3
      },
      // **Wichtig:** damit youtube-Plugin eigene Controls nicht ausblendet
      ytControls: true
    });

    currentSceneIndex = 0;
    player.ready(() => {
      const tech = player.tech({ IWillNotUseThisInPlugins: true });
      const ytPlayer = tech?.ytPlayer;
      if (ytPlayer && ytPlayer.setPlaybackQuality) {
        ytPlayer.setPlaybackQuality('small'); // Niedrigste Qualit√§t
        console.log("Versuche Qualit√§t auf 'small' zu setzen.");
      }
      playScene(currentSceneIndex);
    });

    player.on("timeupdate", () => {

      if (!cutlistData){
        console.log("->>no cutlistData");
        return;
      }
      const scene = cutlistData.scenes[currentSceneIndex];
      if (!scene){
        console.log("->>no scene");
        return;
      }

      
      const currentTime = player.currentTime();
     // console.log("timeupdate "+currentTime);
            
      if (currentTime >= scene.end) {
        console.log("scene end @ "+currentTime+" >= "+scene.end);
        if (autoPlay && currentSceneIndex + 1 < cutlistData.scenes.length) {
          player.pause();//?t
          playScene(currentSceneIndex + 1);
          console.log("now playScene: "+(currentSceneIndex + 1));
        } else {
          console.log("ENDE @ "+(currentSceneIndex));
          player.pause();
          document.getElementById("sceneQuote").innerText = "üéâ Alle Szenen abgespielt.";
        }
      }
    });
  }


async function playScene(index) {
  if (!cutlistData || !cutlistData.scenes) return;
  if (isSceneChanging) {
    console.log("‚è≥ Szenewechsel l√§uft bereits ‚Äì abgebrochen");
    return;
  }

  isSceneChanging = true;
  currentSceneIndex = index;
  updateUI();

  const scene = cutlistData.scenes[index];
  const video = cutlistData.videos.find(v => v.youtubeID === scene.sourceVideoID);
  if (!video) {
    console.warn("Video nicht gefunden f√ºr Szene:", scene);
    isSceneChanging = false;
    return;
  }

  function waitForReady() {
    return new Promise((resolve) => {
      if (player.readyState() >= 2) {
        resolve();
      } else {
        player.one('loadedmetadata', () => resolve());
      }
    });
  }

  function wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function seekTo(time) {
    return new Promise((resolve) => {
      player.currentTime(time);

      const checkInterval = setInterval(() => {
        const currentTime = player.currentTime();
        if (Math.abs(currentTime - time) < 0.5) { // 0.5 Sek Toleranz
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
    });
  }

  try {
    
    const tech = player.tech({ IWillNotUseThisInPlugins: true });
    const currentVideoId = tech?.ytPlayer?.getVideoData ? tech.ytPlayer.getVideoData().video_id : null;
    console.log("‚è≥ set currentVideoId "+currentVideoId);
    if (currentVideoId !== video.youtubeID) {
      console.log(`üé¨ Video-Wechsel: ${currentVideoId} ‚Üí ${video.youtubeID}`);

      await new Promise((resolve) => {
        const timeout = setTimeout(() => {
          console.warn("Timeout beim Warten auf 'canplay'");
          try {
            const tech = player.tech({ IWillNotUseThisInPlugins: true });
            const ytPlayer = tech?.ytPlayer;
            if (ytPlayer) {
              console.log("YouTube Player state:", ytPlayer.getPlayerState());
              console.log("YouTube Player video ID:", ytPlayer.getVideoData().video_id);
            } else {
              console.log("Kein ytPlayer-Objekt verf√ºgbar.");
            }
          } catch (e) {
            console.error("Fehler beim Lesen des Player-Status:", e);
          }
          isSceneChanging = false;  // Flag zur√ºcksetzen, damit es nicht blockiert
          resolve();
        }, 5000);

        player.one('canplay', () => {
          clearTimeout(timeout);
          resolve();
        });

        player.src({
          type: 'video/youtube',
          src: `https://www.youtube.com/watch?v=${video.youtubeID}`
        });
      });



      await wait(5300); // Kleine Pause, YouTube Zeit geben
    }

    await waitForReady();
        console.log("‚è≥ waitForReady");
    await seekTo(scene.start);
        console.log("‚è≥ seekTo");
    await player.play();
        console.log("‚è≥ play");
        console.log(`‚úÖ Szene ${index + 1} gestartet bei ${scene.start}s`);
  } catch (e) {
    console.warn("Fehler beim Abspielen oder Seeken:", e);
  } finally {
    isSceneChanging = false;
  }
}



  function updateUI() {
    const total = cutlistData.scenes.length;
    const scene = cutlistData.scenes[currentSceneIndex];

    document.getElementById("sceneQuote").innerText = scene.quote || "Kein Zitat";
    document.getElementById("progressDisplay").innerText = `üé¨ Szene ${currentSceneIndex + 1} / ${total}`;
  }

  function createSceneButtons() {
    const container = document.getElementById("sceneButtons");
    container.innerHTML = "";
    if (!cutlistData || !cutlistData.scenes) return;

    cutlistData.scenes.forEach((scene, i) => {
      const btn = document.createElement("button");
      btn.className = "scene-button";
      btn.innerText = `‚ñ∂Ô∏è [${formatTime(scene.start)} - ${formatTime(scene.end)}]\n${scene.quote}`;
      btn.title = scene.note || "";
      btn.onclick = () => {
        playScene(i);
      };
      container.appendChild(btn);
    });
  }

  function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return `${m}:${s.toString().padStart(2, "0")}`;
  }

  function applyCutlistFromEditor() {
    try {
      const val = document.getElementById("cutlistEditor").value;
      const data = JSON.parse(val);
      cutlistData = data;
      createSceneButtons();
      initPlayer();
    } catch (e) {
      alert("Ung√ºltiges JSON: " + e.message);
    }
  }

  function downloadCutlist() {
    if (!cutlistData) return;
    const dataStr = JSON.stringify(cutlistData, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "cutlist.json";
    a.click();
    URL.revokeObjectURL(url);
  }

  // Initialisierung
  window.onload = () => {
    init().then(() => {
      createSceneButtons();
    });
  };
</script>
</body>
</html>

