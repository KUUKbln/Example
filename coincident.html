<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Point of Coincidence - Dreieck & Spirale</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    svg {
      background: #f9f9f9;
      cursor: crosshair;
      display: block;
      width: 100%;
      height: 100vh;
      touch-action: manipulation;
    }
    #fullscreenBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      padding: 6px 12px;
      font-size: 14px;
      background: white;
      border: 1px solid #aaa;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }
    #shapeSelect {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      padding: 6px 12px;
      font-size: 14px;
      background: white;
      border: 1px solid #aaa;
      border-radius: 4px;
      user-select: none;
    }
    circle.sender {
      stroke: black;
      stroke-width: 1;
    }
    circle.wave {
      fill: none;
      stroke-width: 2;
    }
    circle.current-x-point {
      fill: black;
    }
    rect.x-point {
      fill: black;
      stroke: none;
    }
    #info {
      position: absolute;
      left: 10px;
      bottom: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre;
      border: 1px solid #ccc;
      border-radius: 4px;
      max-width: 300px;
    }
  </style>
</head>
<body>

<button id="fullscreenBtn" title="Vollbild">ðŸ”²</button>

<select id="shapeSelect" title="Form der Treffpunkte">
  <option value="off">AUS</option>
  <option value="triangle">Dreieck</option>
  <option value="spiral">Spirale</option>
</select>

<svg id="svg" viewBox="0 0 400 400" preserveAspectRatio="xMidYMid meet">
  <!-- Sender -->
  <circle id="R" class="sender" cx="100" cy="100" r="6" fill="red" />
  <circle id="G" class="sender" cx="300" cy="100" r="6" fill="green" />
  <circle id="B" class="sender" cx="100" cy="300" r="6" fill="blue" />

  <!-- Wellen -->
  <circle id="waveR" class="wave" stroke="red" cx="100" cy="100" r="0" />
  <circle id="waveG" class="wave" stroke="green" cx="300" cy="100" r="0" />
  <circle id="waveB" class="wave" stroke="blue" cx="100" cy="300" r="0" />

  <!-- Aktueller Treffpunkt -->
  <circle id="currentXPoint" class="current-x-point" r="6" />
</svg>

<div id="info"></div>

<script>
(() => {
  const svg = document.getElementById('svg');
  const waveR = document.getElementById('waveR');
  const waveG = document.getElementById('waveG');
  const waveB = document.getElementById('waveB');
  const currentXPoint = document.getElementById('currentXPoint');
  const info = document.getElementById('info');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const shapeSelect = document.getElementById('shapeSelect');

  const posR = { x: 100, y: 100 };
  const posG = { x: 300, y: 100 };
  const posB = { x: 100, y: 300 };

  const v = 100; // px/s
  let startTime = null;
  let animationFrameId = null;
  let posX = { x: 200, y: 160 };

  let t_x, tR, tG, tB, dR, dG, dB;

  let autoPlay = true;
  let autoResumeTimer = null;
  const autoResumeDelay = 5000;

  let presetPoints = [];
  let currentPresetIndex = 0;

  function dist(a, b) {
    return Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
  }

  // Hilfsfunktion zum linearen Interpolieren zwischen 2 Punkten
  function lerpPoint(p1, p2, t) {
    return {
      x: p1.x + (p2.x - p1.x) * t,
      y: p1.y + (p2.y - p1.y) * t
    };
  }

  // Dreieck-Grundpunkte (gleich wie zuvor)
  const triangleBasePoints = [
    {x: 200, y: 120},
    {x: 280, y: 280},
    {x: 120, y: 280}
  ];

  // Funktion: Dreieck-Kanten in insgesamt n Punkte aufteilen
  function generateTrianglePoints(n) {
    const points = [];
    const edges = 3;
    const pointsPerEdge = Math.floor(n / edges);
    const remainder = n % edges;

    for(let edge=0; edge<edges; edge++) {
      const start = triangleBasePoints[edge];
      const end = triangleBasePoints[(edge+1) % edges];
      let count = pointsPerEdge + (edge === 0 ? remainder : 0);

      for(let i = 0; i < count; i++) {
        const t = i / count;
        points.push(lerpPoint(start, end, t));
      }
    }
    return points;
  }

  // Spirale: centerX, centerY, windungen, punktzahl, abstand pro Radiant
  function generateSpiralPoints(centerX, centerY, turns, pointsCount, spacing) {
    const points = [];
    const maxAngle = turns * 2 * Math.PI;
    for(let i = 0; i < pointsCount; i++) {
      const t = i / (pointsCount - 1);
      const angle = t * maxAngle;
      const radius = spacing * angle;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      points.push({x, y});
    }
    return points;
  }

  function generatePoints(shape) {
    if(shape === 'triangle') return generateTrianglePoints(15);
    if(shape === 'spiral') return generateSpiralPoints(200, 180, 7, 300, 20);
    return [];
  }

  function addAccumulatedXPoint(x, y) {
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("class", "x-point");
    rect.setAttribute("width", 4);
    rect.setAttribute("height", 4);
    rect.setAttribute("x", x - 2);
    rect.setAttribute("y", y - 2);
    svg.appendChild(rect);
  }

  function prepareAnimation() {
    dR = dist(posX, posR);
    dG = dist(posX, posG);
    dB = dist(posX, posB);

    const maxD = Math.max(dR, dG, dB);
    t_x = maxD / v;

    tR = t_x - dR / v;
    tG = t_x - dG / v;
    tB = t_x - dB / v;

    startTime = performance.now() / 1000;

    waveR.setAttribute("r", 0);
    waveG.setAttribute("r", 0);
    waveB.setAttribute("r", 0);

    currentXPoint.setAttribute("cx", posX.x);
    currentXPoint.setAttribute("cy", posX.y);

    if(animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
    }
    animate();
  }

  function animate() {
    const now = performance.now() / 1000;
    const t = now - startTime;

    const rR = t >= tR ? Math.min(v * (t - tR), dR) : 0;
    const rG = t >= tG ? Math.min(v * (t - tG), dG) : 0;
    const rB = t >= tB ? Math.min(v * (t - tB), dB) : 0;

    waveR.setAttribute("r", rR);
    waveG.setAttribute("r", rG);
    waveB.setAttribute("r", rB);

    info.textContent = 
      `Ziel: (${posX.x.toFixed(1)}, ${posX.y.toFixed(1)})\n` +
      `Dist R: ${dR.toFixed(1)} px\n` +
      `Dist G: ${dG.toFixed(1)} px\n` +
      `Dist B: ${dB.toFixed(1)} px\n` +
      `Treffzeit: ${t_x.toFixed(3)} s\n` +
      `Start R: ${tR.toFixed(3)} s\n` +
      `Start G: ${tG.toFixed(3)} s\n` +
      `Start B: ${tB.toFixed(3)} s\n` +
      `Anim Zeit: ${t.toFixed(3)} s\n` +
      `AutoPlay: ${autoPlay ? "AN" : "PAUSE"}`;

    if(rR === dR && rG === dG && rB === dB) {
      addAccumulatedXPoint(posX.x, posX.y);

      if(autoPlay && presetPoints.length > 0) {
        setTimeout(() => {
          currentPresetIndex = (currentPresetIndex + 1) % presetPoints.length;
          posX = presetPoints[currentPresetIndex];
          prepareAnimation();
        }, 100);
      }

      animationFrameId = null;
      return;
    }

    animationFrameId = requestAnimationFrame(animate);
  }

  function pointerHandler(event) {
    event.preventDefault();

    autoPlay = false;
    if(autoResumeTimer) clearTimeout(autoResumeTimer);
    autoResumeTimer = setTimeout(() => {
      autoPlay = true;
      if(presetPoints.length > 0) {
        currentPresetIndex = 0;
        posX = presetPoints[currentPresetIndex];
        prepareAnimation();
      }
    }, autoResumeDelay);

    const pt = svg.createSVGPoint();
    pt.x = event.clientX;
    pt.y = event.clientY;
    const cursorpt = pt.matrixTransform(svg.getScreenCTM().inverse());

    posX = { x: cursorpt.x, y: cursorpt.y };
    prepareAnimation();
  }

  function loadPreset(shape) {
    presetPoints = generatePoints(shape);
    currentPresetIndex = 0;
    if(presetPoints.length > 0) {
      posX = presetPoints[0];
      prepareAnimation();
      autoPlay = true;
    } else {
      autoPlay = false;
      if(animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      waveR.setAttribute("r", 0);
      waveG.setAttribute("r", 0);
      waveB.setAttribute("r", 0);
      info.textContent = 'Automatik AUS';
      currentXPoint.setAttribute("cx", -100);
      currentXPoint.setAttribute("cy", -100);
    }
  }

  fullscreenBtn.addEventListener('click', () => {
    if(!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  });

  shapeSelect.addEventListener('change', (e) => {
    loadPreset(e.target.value);
  });

  svg.addEventListener('pointerdown', pointerHandler);

  loadPreset('off');
})();
</script>

</body>
</html>
