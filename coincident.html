<!--

  Titel: Point of Coincodence
  ðŸ”§ SVG-Visualisierung: Synchrone SignalÃ¼berlagerung

  Diese Anwendung zeigt drei Sender (rot, grÃ¼n, blau), die Signale aussenden,
  die sich exakt an einem vom Nutzer gesetzten Treffpunkt "X" synchron treffen.

  âœ¨ Features:
  - Die Signale reisen mit konstanter Geschwindigkeit v.
  - Die Signale starten zu unterschiedlichen Zeiten, sodass sie gleichzeitig am Treffpunkt X ankommen.
  - Treffpunkte kÃ¶nnen durch Klick ins SVG gesetzt werden.
  - Alte Treffpunkte bleiben als kleine schwarze Quadrate sichtbar.
  - Vollbildmodus per Button (ðŸ”²).

  ðŸ§  Berechnung:
  - FÃ¼r jeden Sender wird die Distanz d_i zum Treffpunkt X berechnet.
  - Die frÃ¼hestmÃ¶gliche Treffzeit ist: t_x = max(d_i) / v
  - Startzeit fÃ¼r Sender i: t_i = t_x - d_i / v

  ðŸ“ Darstellung:
  - Sender: farbige Kreise (RGB).
  - Signale: animierte Kreise (Wellen), die von den Sendern ausgehen.
  - Aktueller Treffpunkt X: schwarzer Kreis.
  - Vorherige Treffpunkte: schwarze Quadrate.

  Entwickelt fÃ¼r experimentelle Visualisierung von SignalÃ¼berlagerung / Triangulation.
-->

<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Point of Coincidence</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    svg {
      background: #f9f9f9;
      cursor: crosshair;
      display: block;
      width: 100%;
      height: 100vh;
    }
    #fullscreenBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      padding: 6px 12px;
      font-size: 14px;
      background: white;
      border: 1px solid #aaa;
      border-radius: 4px;
      cursor: pointer;
    }
    circle.sender {
      stroke: black;
      stroke-width: 1;
    }
    circle.wave {
      fill: none;
      stroke-width: 2;
    }
    circle.current-x-point {
      fill: black;
      r: 6;
    }
    rect.x-point {
      fill: black;
      stroke: none;
    }
    #info {
      position: absolute;
      left: 10px;
      bottom: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
  </style>
</head>
<body>

<button id="fullscreenBtn">ðŸ”² Vollbild</button>

<svg id="svg" viewBox="0 0 400 400" preserveAspectRatio="xMidYMid meet">
  <!-- Sender -->
  <circle id="R" class="sender" cx="100" cy="100" r="6" fill="red" />
  <circle id="G" class="sender" cx="300" cy="100" r="6" fill="green" />
  <circle id="B" class="sender" cx="100" cy="300" r="6" fill="blue" />

  <!-- Wellen -->
  <circle id="waveR" class="wave" stroke="red" cx="100" cy="100" r="0" />
  <circle id="waveG" class="wave" stroke="green" cx="300" cy="100" r="0" />
  <circle id="waveB" class="wave" stroke="blue" cx="100" cy="300" r="0" />

  <!-- Aktueller Treffpunkt -->
  <circle id="currentXPoint" class="current-x-point" r="6" />
</svg>

<div id="info"></div>

<script>
(() => {
  const svg = document.getElementById('svg');
  const waveR = document.getElementById('waveR');
  const waveG = document.getElementById('waveG');
  const waveB = document.getElementById('waveB');
  const currentXPoint = document.getElementById('currentXPoint');
  const info = document.getElementById('info');
  const fullscreenBtn = document.getElementById('fullscreenBtn');

  const posR = { x: 100, y: 100 };
  const posG = { x: 300, y: 100 };
  const posB = { x: 100, y: 300 };

  const v = 100; // px/s
  let startTime = null;
  let animationFrameId = null;

  let posX = { x: 200, y: 160 }; // aktueller Treffpunkt

  function dist(a, b) {
    return Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
  }

  function radius(t, t_start) {
    const dt = t - t_start;
    return dt < 0 ? 0 : dt * v;
  }

  function checkArrival(t) {
    const tol = 3;
    return (
      Math.abs(radius(t, tR) - dR) < tol &&
      Math.abs(radius(t, tG) - dG) < tol &&
      Math.abs(radius(t, tB) - dB) < tol
    );
  }

  function updateInfo(t) {
    info.textContent =
      `Aktuelle Zeit: ${t.toFixed(2)} s\n` +
      `Geschwindigkeit: ${v} px/s\n` +
      `Treffzeit t_x: ${t_x.toFixed(3)} s\n` +
      `Startzeiten: R=${tR.toFixed(3)}, G=${tG.toFixed(3)}, B=${tB.toFixed(3)}\n` +
      `Distanzen: dR=${dR.toFixed(2)}, dG=${dG.toFixed(2)}, dB=${dB.toFixed(2)}\n` +
      `Treffpunkt: (${posX.x.toFixed(1)}, ${posX.y.toFixed(1)})\n` +
      `Getroffen? ${checkArrival(t) ? 'JA' : 'NEIN'}`;
  }

  function animate(timestamp) {
    if (!startTime) startTime = timestamp;
    const t = (timestamp - startTime) / 1000;

    waveR.setAttribute('r', radius(t, tR));
    waveG.setAttribute('r', radius(t, tG));
    waveB.setAttribute('r', radius(t, tB));

    updateInfo(t);

    if (checkArrival(t)) {
      cancelAnimationFrame(animationFrameId);
      return;
    }

    animationFrameId = requestAnimationFrame(animate);
  }

  function addAccumulatedXPoint(x, y) {
    const size = 6; // GrÃ¶ÃŸe des vorherigen Punkts
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("class", "x-point");
    rect.setAttribute("x", x - size/2);
    rect.setAttribute("y", y - size/2);
    rect.setAttribute("width", size);
    rect.setAttribute("height", size);
    svg.appendChild(rect);
  }

  function startAnimation() {
    dR = dist(posR, posX);
    dG = dist(posG, posX);
    dB = dist(posB, posX);

    t_x = Math.max(dR, dG, dB) / v;

    tR = t_x - dR / v;
    tG = t_x - dG / v;
    tB = t_x - dB / v;

    currentXPoint.setAttribute('cx', posX.x);
    currentXPoint.setAttribute('cy', posX.y);

    waveR.setAttribute('cx', posR.x);
    waveR.setAttribute('cy', posR.y);
    waveG.setAttribute('cx', posG.x);
    waveG.setAttribute('cy', posG.y);
    waveB.setAttribute('cx', posB.x);
    waveB.setAttribute('cy', posB.y);

    startTime = null;

    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    animationFrameId = requestAnimationFrame(animate);
  }

  svg.addEventListener('click', (e) => {
    const pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

    addAccumulatedXPoint(posX.x, posX.y);
    posX = { x: svgP.x, y: svgP.y };
    startAnimation();
  });

  // Vollbild-Button
  fullscreenBtn.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      svg.requestFullscreen().catch(err => {
        alert(`Vollbildmodus konnte nicht aktiviert werden: ${err.message}`);
      });
    } else {
      document.exitFullscreen();
    }
  });

  // Initialer Startpunkt
  addAccumulatedXPoint(posX.x, posX.y);
  startAnimation();
})();
</script>

</body>
</html>
