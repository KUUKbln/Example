<!--
  ðŸ”§ SVG-Visualisierung: Point of Coincidence (Synchrone SignalÃ¼berlagerung mit Automatik und Formwahl)

  Features:
  - 3 Sender (RGB) senden Signale, die sich synchron an Treffpunkt X treffen.
  - Treffpunkte bleiben als schwarze Quadrate erhalten, aktueller als schwarzer Kreis.
  - Automatik lÃ¤uft mit 20 Punkten in einer Form:
    â€¢ Kreis, Dreieck, Zufallswolke (wahlweise).
  - Klick oder Touch setzt neuen Punkt, stoppt Automatik fÃ¼r 5s.
  - Vollbild-Schalter.

  Berechnung:
  - Distanz zu Sendern bestimmt Startzeiten fÃ¼r SynchronitÃ¤t.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Point of Coincidence</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    svg {
      background: #f9f9f9;
      cursor: crosshair;
      display: block;
      width: 100%;
      height: 100vh;
      touch-action: manipulation;
    }
    #fullscreenBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      padding: 6px 12px;
      font-size: 14px;
      background: white;
      border: 1px solid #aaa;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }
    #shapeSelect {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      padding: 6px 12px;
      font-size: 14px;
      background: white;
      border: 1px solid #aaa;
      border-radius: 4px;
      user-select: none;
    }
    circle.sender {
      stroke: black;
      stroke-width: 1;
    }
    circle.wave {
      fill: none;
      stroke-width: 2;
    }
    circle.current-x-point {
      fill: black;
    }
    rect.x-point {
      fill: black;
      stroke: none;
    }
    #info {
      position: absolute;
      left: 10px;
      bottom: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre;
      border: 1px solid #ccc;
      border-radius: 4px;
      max-width: 300px;
    }
  </style>
</head>
<body>

<button id="fullscreenBtn" title="Vollbild">ðŸ”²</button>

<select id="shapeSelect" title="Form der Treffpunkte">
  <option value="circle">Kreis</option>
  <option value="triangle">Dreieck</option>
  <option value="random">Zufallswolke</option>
</select>

<svg id="svg" viewBox="0 0 400 400" preserveAspectRatio="xMidYMid meet">
  <!-- Sender -->
  <circle id="R" class="sender" cx="100" cy="100" r="6" fill="red" />
  <circle id="G" class="sender" cx="300" cy="100" r="6" fill="green" />
  <circle id="B" class="sender" cx="100" cy="300" r="6" fill="blue" />

  <!-- Wellen -->
  <circle id="waveR" class="wave" stroke="red" cx="100" cy="100" r="0" />
  <circle id="waveG" class="wave" stroke="green" cx="300" cy="100" r="0" />
  <circle id="waveB" class="wave" stroke="blue" cx="100" cy="300" r="0" />

  <!-- Aktueller Treffpunkt -->
  <circle id="currentXPoint" class="current-x-point" r="6" />
</svg>

<div id="info"></div>

<script>
(() => {
  const svg = document.getElementById('svg');
  const waveR = document.getElementById('waveR');
  const waveG = document.getElementById('waveG');
  const waveB = document.getElementById('waveB');
  const currentXPoint = document.getElementById('currentXPoint');
  const info = document.getElementById('info');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const shapeSelect = document.getElementById('shapeSelect');

  const posR = { x: 100, y: 100 };
  const posG = { x: 300, y: 100 };
  const posB = { x: 100, y: 300 };

  const v = 100; // px/s
  let startTime = null;
  let animationFrameId = null;
  let posX = { x: 200, y: 160 };

  let t_x, tR, tG, tB, dR, dG, dB;

  let autoPlay = true;
  let autoResumeTimer = null;
  const autoResumeDelay = 5000;

  let presetPoints = [];
  let currentPresetIndex = 0;

  function dist(a, b) {
    return Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
  }

  function radius(t, t_start) {
    const dt = t - t_start;
    return dt < 0 ? 0 : dt * v;
  }

  function checkArrival(t) {
    const tol = 3;
    return (
      Math.abs(radius(t, tR) - dR) < tol &&
      Math.abs(radius(t, tG) - dG) < tol &&
      Math.abs(radius(t, tB) - dB) < tol
    );
  }

  function updateInfo(t) {
    info.textContent =
      `Zeit: ${t.toFixed(2)} s\n` +
      `Treffzeit t_x: ${t_x.toFixed(3)} s\n` +
      `Startzeiten: R=${tR.toFixed(3)}, G=${tG.toFixed(3)}, B=${tB.toFixed(3)}\n` +
      `Treffpunkt: (${posX.x.toFixed(1)}, ${posX.y.toFixed(1)})\n` +
      `Automatik: ${autoPlay ? 'ðŸŸ¢ aktiv' : 'ðŸ”´ unterbrochen'}`;
  }

  function animate(timestamp) {
    if (!startTime) startTime = timestamp;
    const t = (timestamp - startTime) / 1000;

    waveR.setAttribute('r', radius(t, tR));
    waveG.setAttribute('r', radius(t, tG));
    waveB.setAttribute('r', radius(t, tB));

    updateInfo(t);

    if (checkArrival(t)) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
      if (autoPlay) {
        setTimeout(() => {
          advancePreset();
        }, 300);
      }
      return;
    }

    animationFrameId = requestAnimationFrame(animate);
  }

  function addAccumulatedXPoint(x, y) {
    const size = 6;
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("class", "x-point");
    rect.setAttribute("x", x - size/2);
    rect.setAttribute("y", y - size/2);
    rect.setAttribute("width", size);
    rect.setAttribute("height", size);
    svg.appendChild(rect);
  }

  function prepareAnimation() {
    dR = dist(posR, posX);
    dG = dist(posG, posX);
    dB = dist(posB, posX);

    t_x = Math.max(dR, dG, dB) / v;

    tR = t_x - dR / v;
    tG = t_x - dG / v;
    tB = t_x - dB / v;

    currentXPoint.setAttribute('cx', posX.x);
    currentXPoint.setAttribute('cy', posX.y);

    waveR.setAttribute('cx', posR.x);
    waveR.setAttribute('cy', posR.y);
    waveG.setAttribute('cx', posG.x);
    waveG.setAttribute('cy', posG.y);
    waveB.setAttribute('cx', posB.x);
    waveB.setAttribute('cy', posB.y);

    startTime = null;
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    animationFrameId = requestAnimationFrame(animate);
  }

  // Generiert Punkte im Kreis
  function generateCircularPoints(n, centerX = 200, centerY = 200, radius = 40) {
    const points = [];
    const angleOffset = Math.random() * 2 * Math.PI;
    for (let i = 0; i < n; i++) {
      const angle = angleOffset + (2 * Math.PI * i) / n;
      points.push({
        x: centerX + Math.cos(angle) * radius,
        y: centerY + Math.sin(angle) * radius
      });
    }
    return points;
  }

  // Generiert Punkte fÃ¼r gleichseitiges Dreieck (3 Ecken mit n/3 Punkten pro Seite)
  function generateTrianglePoints(n, centerX = 200, centerY = 200, size = 80) {
    const points = [];
    const sidePoints = Math.floor(n / 3);
    const remainder = n - sidePoints * 3;
    // Eckpunkte
    const A = {
      x: centerX,
      y: centerY - size / Math.sqrt(3)
    };
    const B = {
      x: centerX - size / 2,
      y: centerY + size / (2 * Math.sqrt(3))
    };
    const C = {
      x: centerX + size / 2,
      y: centerY + size / (2 * Math.sqrt(3))
    };

    function interpolate(p1, p2, t) {
      return { x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t };
    }

    for (let i = 0; i < sidePoints; i++) {
      const t = i / sidePoints;
      points.push(interpolate(A, B, t));
    }
    for (let i = 0; i < sidePoints; i++) {
      const t = i / sidePoints;
      points.push(interpolate(B, C, t));
    }
    for (let i = 0; i < sidePoints + remainder; i++) {
      const t = i / (sidePoints + remainder);
      points.push(interpolate(C, A, t));
    }
    return points;
  }

  // ZufÃ¤llige Punkte in begrenztem Bereich (Wolke)
  function generateRandomPoints(n, minX = 160, maxX = 240, minY = 160, maxY = 240) {
    const points = [];
    for (let i = 0; i < n; i++) {
      points.push({
        x: minX + Math.random() * (maxX - minX),
        y: minY + Math.random() * (maxY - minY)
      });
    }
    return points;
  }

  function generatePoints(shape) {
    switch (shape) {
      case 'triangle': return generateTrianglePoints(20);
      case 'random': return generateRandomPoints(20);
      case 'circle':
      default: return generateCircularPoints(20);
    }
  }

  function advancePreset() {
    if (currentPresetIndex >= presetPoints.length) {
      presetPoints = generatePoints(shapeSelect.value);
      currentPresetIndex = 0;
    }
    addAccumulatedXPoint(posX.x, posX.y);
    posX = presetPoints[currentPresetIndex++];
    prepareAnimation();
  }

  function resumeAutoPlay() {
    autoPlay = true;
    advancePreset();
  }

  function userSetPoint(x, y) {
    if (animationFrameId) cancelAnimationFrame(animationFrameId);

    autoPlay = false;
    if (autoResumeTimer) clearTimeout(autoResumeTimer);
    autoResumeTimer = setTimeout(resumeAutoPlay, autoResumeDelay);

    addAccumulatedXPoint(posX.x, posX.y);
    posX = { x, y };
    prepareAnimation();
  }

  // Neuer pointerHandler mit Touch/Maus kompatibel + CTM-Check
  function pointerHandler(e) {
    e.preventDefault();

    let clientX, clientY;

    if (e.touches && e.touches.length > 0) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }

    const pt = svg.createSVGPoint();
    pt.x = clientX;
    pt.y = clientY;

    const ctm = svg.getScreenCTM();
    if (!ctm) {
      console.warn('SVG CTM ist null, Klick ignoriert.');
      return;
    }

    const svgP = pt.matrixTransform(ctm.inverse());

    userSetPoint(svgP.x, svgP.y);
  }

  svg.addEventListener('pointerdown', pointerHandler, { passive: false });

  fullscreenBtn.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      svg.requestFullscreen().catch(err => {
        alert(`Vollbildmodus konnte nicht aktiviert werden: ${err.message}`);
      });
    } else {
      document.exitFullscreen();
    }
  });

  shapeSelect.addEventListener('change', () => {
    presetPoints = generatePoints(shapeSelect.value);
    currentPresetIndex = 0;
    autoPlay = true;
    addAccumulatedXPoint(posX.x, posX.y);
    posX = presetPoints[0];
    prepareAnimation();
  });

  // Initialisierung
  presetPoints = generatePoints(shapeSelect.value);
  posX = presetPoints[0];
  currentPresetIndex = 1;
  prepareAnimation();

})();
</script>

</body>
</html>

